 <!DOCTYPE html>
 <html lang="en">
 <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="main.css">
    <!-- <script src="client.js"></script> -->
 </head>
 <body>
    <div id="main">
        <div>
            <input id="usernameInput" value="asd"/>
            <button id="connect">Connect</button>
        </div>

            <button id="sendFile">Send File</button>
        
        <div>
            <input id="peerUsernameInput"/>
            <button id="sendPeer">Send Peer</button>
        </div>

        <button id="ping">Ping</button>

        <button id="disconnect">Disconnect</button>

    </div>
    <script>
        //const socket = new WebSocket('ws://localhost:8080');
        //const socket = new WebSocket('ws://192.168.1.158:8080');
        
        let socket = null;  //websocket connection
        let username = null;
        let uuid = null;
        let peersUserName = [];

        let localConnection = null;
        let peerConnection = null;

        //bind connection with connect button
        document.getElementById('connect').onclick = connectWebSocket;
        function connectWebSocket(){
            username = document.getElementById('usernameInput').value;
            console.log("username = " + username);


            if(socket == null || socket.readyState === WebSocket.CLOSED){
                socket = new WebSocket('ws://192.168.1.158:8080');  //DEBUG: remove this in final product

                socket.onopen = () => {
                    console.log('Connected to WebSocket server');
                    socket.send(JSON.stringify({type: 'username', username: username}));
                };
        
                socket.onmessage = async (event) => {
                    const jsonObj = JSON.parse(event.data);

                    switch(jsonObj.type){   //type: uuid, message, userList, changeName
                        case 'uuid':
                            uuid = jsonObj.uuid;
                            console.log("assigned uuid: " + jsonObj.uuid);
                            break;

                        case 'message':
                            const message = jsonObj.text;
                            console.log('message from server: ' + message);
                            break;

                        case 'reject':
                            console.log("connection rejected");
                            console.log('message from server: ' + jsonObj.text);
                            break;

                        case 'userlist':
                            let userlist = jsonObj.userlist;
                            for(let user of userlist){
                                console.log("username = " + user);
                            }
                            console.log("end of user list");
                            break;

                        case 'offer':   //webrtc set up for receiver                     
                            // Create RTCPeerConnection
                            localConnection = new RTCPeerConnection();

                            // Set the remote description with the incoming offer
                            await localConnection.setRemoteDescription(new RTCSessionDescription(jsonObj.offer));

                            // Create an answer to send back to the offerer
                            const answer = await localConnection.createAnswer();
                            await localConnection.setLocalDescription(answer);
                            socket.send(JSON.stringify({type: 'answer', answer: localConnection.localDescription, target: jsonObj.sender }));

                            // Handle incoming ICE candidates
                            localConnection.onicecandidate = ({ candidate }) => {
                                console.log("localConnection has received icecandidate");
                                if (candidate) {
                                    socket.send(JSON.stringify({ type: 'iceCandidate', candidate: candidate, target: jsonObj.sender}));
                                }
                            };

                            // Set up data channel
                            var datachannel = null;
                            localConnection.ondatachannel = (event) => {
                                datachannel = event.channel;
                                console.log("received data channel, state = " + datachannel.readyState);
                                
                                datachannel.onopen = () => {
                                    console.log("Data channel open");
                                    peerConnection = dataChannel;
                                } 
                                
                                datachannel.onmessage = (event) => {
                                    console.log("Received peer message from data channel:" + event.data);
                                }   
                            }
                            
                            //var dataChannel = localConnection.createDataChannel('fileTransfer');
                            
             
                            

                            break;

                        case 'answer':
                            await localConnection.setRemoteDescription(new RTCSessionDescription(jsonObj.answer));
                            console.log("Received answer and set as remote description");
                            console.log("connection state: " + localConnection.connectionState);
                            break;

                        case 'iceCandidate':
                            let candidate = new RTCIceCandidate(jsonObj.candidate);
                            await localConnection.addIceCandidate(candidate);
                            break;
                    }
                };
        
                socket.onclose = () => {
                    console.log('WebSocket connection closed');
                };
        
                socket.onerror = (error) => {
                    console.log('WebSocket error:', error);
                };
            }else{
                console.log("WARNING, you already have a connection!");
            }
        }
        
        //bind function with ping button
        document.getElementById('ping').onclick = () =>{
            //console.log("socket state is " + (socket.readyState === WebSocket.OPEN));
            if(peerConnection.readyState === "open"){
                peerConnection.send(`Message by peer ${username}`);
                console.log("data channel is open and a message is sent");
            }else{
                console.log("data channel is not open!");
            }
        }


        //bind function with sendFile button
        document.getElementById('sendFile').onclick = sendMessage;
        function sendMessage(){
            if (socket.readyState === WebSocket.OPEN) {
                let message = {
                    text: 'A friendly message sent by client side',
                    type: 'message'
                }

                socket.send(JSON.stringify(message));
                console.log('Message sent to server');
            } else {
                console.log('WebSocket connection is not open');
            }
        }
        
        //bind function with sendPeer button
        //send webRTC offer via websocket
        document.getElementById('sendPeer').onclick = sendPeer;
        function sendPeer(){
            var targetUsername = document.getElementById('peerUsernameInput').value;
            //socket.send(JSON.stringify({type: 'offer', message: `Peer message from ${username}`, target: targetUsername, sender: username})); DEBUG
            setupWebRTC(targetUsername);
            console.log(`send offer to peer ${targetUsername}`);
        }

        //content moved to setupWebRTC
        async function createOffer(targetUsername){

        }

        //sender webrtc set up
        async function setupWebRTC(targetUsername){
            // Create the RTCPeerConnection
            localConnection = new RTCPeerConnection();

            
            // Create a data channel for file transfer
            const dataChannel = localConnection.createDataChannel('fileTransfer');
            peerConnection = dataChannel;

            // Handle data channel events
            dataChannel.onopen = () => {
                console.log('Data channel is open');
                const message = `Hello from ${username}`;
                dataChannel.send(message);
                console.log(`Sent message: ${message}`);
            }
            

            dataChannel.onmessage = (event) => {
                console.log('Received file:', event.data);  // Handle the received file
            };

            // Set up ICE candidate handler
            localConnection.onicecandidate = ({ candidate }) => {
                console.log("localConnection has received icecandidate");
                if (candidate) {
                    socket.send(JSON.stringify({ type: 'iceCandidate', candidate: candidate, target: targetUsername , sender: username}));
                }
            };

            // Create and send SDP offer to target
            const offer = await localConnection.createOffer();
            await localConnection.setLocalDescription(offer);
            socket.send(JSON.stringify({ type: 'offer', offer: offer, target: targetUsername, sender: username}));
        }

        //bind function with disconnect button
        document.getElementById('disconnect').onclick = () =>{
            socket.close();
        }
    
    
        function log(text) {
            var time = new Date();
            console.log("[" + time.toLocaleTimeString() + "] " + text);
        }
        

    </script>
 </body>


 </html>