 <!DOCTYPE html>
 <html lang="en">
 <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="main.css">
    <!-- <script src="client.js"></script> -->
 </head>
 <body>
    <div id="main">
        <div id="connectionUI">
            <h2>Connection</h2>
            <div>
                <input id="usernameInput" value="asd"/>
                <button id="connect">Connect</button>
            </div>
     
            <div>
                <input id="peerUsernameInput"/>
                <button id="sendPeer">Send Peer</button>
            </div>
    
            <button id="ping">Ping</button>
    
            <button id="disconnect">Disconnect</button>
    
            <div id="userlistDiv">
                <h2>Active Users</h2>
                <ul id="userList"></ul>
            </div>
        </div>


        <div id="fileTransferUI">
            <h2>File Transfer</h2>
            <input type="file" id="fileInput">
            <p id="fileName">File: N/A</p>
            <p id="fileSize">Size: N/A</p>
            <progress id="sendProgress" value="0" max="100"></progress>
            <p id="sendStatus">Status: Not started</p>
            <button id="sendFile">Send File</button>
            <button id="channelDisconnect">Disconnect</button>
            <a id="downloadLink" style="display: none;">Download</a>
        </div>
    </div>

    <script>
        /*
            Unresolved BUG

            #1: When sending large files, the program errors out with RTCdata channel is full
                    issue is partly solved with adding flow control, but still not stable
            #2 The worry that the poorly written receiver code would make all the received chunks
                store in memory, making the program eating too much memory
            #3 Handling peer user disconnecting

        */

        //const socket = new WebSocket('ws://localhost:8080');
        //const socket = new WebSocket('ws://192.168.1.158:8080');
        
        let socket = null;          //websocket connection
        let username = null;        //username of the user
        let uuid = null;            //uuid assigned by websocket server

        let peerConnection = null; //webrtc connection
        let dataChannel = null;     //webrtc data channel connection
        let userlist = [];        //list of usernames, including self

        //bind connection with connect button
        document.getElementById('connect').onclick = () => connectWebSocket();
        function connectWebSocket(){
            username = document.getElementById('usernameInput').value;
            console.log("username = " + username);


            if(socket == null || socket.readyState === WebSocket.CLOSED){
                socket = new WebSocket('ws://192.168.1.158:8080');  //DEBUG: remove this in final product

                socket.onopen = () => {
                    console.log('Connected to WebSocket server');
                    socket.send(JSON.stringify({type: 'username', username: username}));
                };
        
                socket.onmessage = async (event) => {
                    const jsonObj = JSON.parse(event.data);

                    switch(jsonObj.type){   //type: uuid, message, userList, changeName
                        case 'uuid':
                            uuid = jsonObj.uuid;
                            console.log("assigned uuid: " + jsonObj.uuid);
                            break;

                        case 'message':
                            const message = jsonObj.text;
                            console.log('message from server: ' + message);
                            break;

                        case 'reject':
                            console.log("connection rejected");
                            console.log('message from server: ' + jsonObj.text);
                            break;

                        case 'userlist':
                            userlist = jsonObj.userlist;
                            updateUserList(userlist);
                            logUserList(userlist);
                            break;

                        case 'offer':   //webrtc set up for receiver                     
                            // Create RTCPeerConnection
                            peerConnection = new RTCPeerConnection({
                                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]  // Optional: Add STUN for testing
                                //iceServers: []
                            });

                            // Set the remote description with the incoming offer
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(jsonObj.offer));

                            // Create an answer to send back to the offerer
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);
                            socket.send(JSON.stringify({type: 'answer', answer: peerConnection.localDescription, target: jsonObj.sender }));

                            console.log("received offer! sending answer back...");
                            // Handle incoming ICE candidates (moved to iceready for flow control) (moved back)
                            
                            peerConnection.onicecandidate = ({ candidate }) => {
                                console.log("peerConnection has received icecandidate");
                                if (candidate) {
                                    console.log("new icecandidate found: " + candidate.candidate);
                                    socket.send(JSON.stringify({ type: 'iceCandidate', candidate: candidate, target: jsonObj.sender}));
                                }
                            };
                            

                            // Set up data channel for receiver
                            peerConnection.ondatachannel = (event) => {
                                dataChannel = event.channel;
                                console.log("received data channel, state = " + dataChannel.readyState);
                                
                                dataChannel.onopen = () => {
                                    console.log("Data channel open");
                                } 
                                
                                dataChannel.onmessage = (event) => {
                                    if(typeof event.data === 'string'){ //receive metadata
                                        const jsonObj = JSON.parse(event.data);
                                        fileNameElement.textContent = `File: ${jsonObj.fileName}`;

                                        fileSize = jsonObj.fileSize;
                                        fileType = jsonObj.fileType;
                                        fileName = jsonObj.fileName;

                                        let sizeUnitArray = ["byte", "KB", "MB", "GB"];
                                        let sizeUnit = 0;
                                        let sizeDisplay = jsonObj.fileSize;

                                        for(let i=0; i<4; i++){
                                            if(sizeDisplay >= 1024){
                                                sizeDisplay /= 1024;
                                                sizeUnit++;
                                            }
                                        }

                                        fileSizeElement.textContent = `Size: ${sizeDisplay.toFixed(2)} ${sizeUnitArray[sizeUnit]}`;
                                        console.log("data channel: file metadata received!");

                                    }else{    
                                        receivedChunks.push(event.data);
                                        receivedBytes += event.data.byteLength;
                                        //console.log(event.data);  DEBUG
                                        
                                        //console.log("DEBUG: received byteLength = " + event.data.byteLength); DEBUG
                                        const percentComplete = (receivedBytes/fileSize) *100;  //DEBUG: poorly used variable (read)
                                        sendProgress.value = percentComplete;
                                        sendStatus.textContent = `Status: ${percentComplete.toFixed(2)}% received`;

                                        if (receivedBytes === fileSize) {
                                            sendStatus.textContent = 'Status: Transfer complete';
                                            reconstructAndDownloadFile();  // File is fully received
                                        }
                                    }                                  
                                    //console.log("Received peer message from data channel:" + event.data);
                                }   
                            }
                            break;

                        case 'answer':
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(jsonObj.answer));
                            console.log("Received answer and set as remote description");
                            console.log("connection state: " + peerConnection.connectionState);
                            console.log("ready to exchange icecandidate");

                            var targetUsername = document.getElementById('peerUsernameInput').value;
                            
                            /*
                            peerConnection.onicecandidate = ({ candidate }) => {    // ready to exchange icecandidate, sender side
                                socket.send(JSON.stringify({ type: 'iceCandidate', candidate: candidate, target: targetUsername}));
                                if (candidate) {
                                    console.log(`found new icecandidate, type ${candidate.candidate} , sending`);
                                }else{
                                    console.log("ERROR! No icecandidate!");
                                }
                            };
                            */
                            
                            peerConnection.onicegatheringstatechange = () => {
                                console.log("ICE Gathering State:", peerConnection.iceGatheringState);
                            };

                            peerConnection.onconnectionstatechange = () => {
                                console.log('PeerC onnection State:', peerConnection.connectionState);
                            };

                            socket.send(JSON.stringify({type: 'iceready', target: targetUsername, sender: username}));
                            break;
                        
                        case 'iceready':    /* ready to exchange icecandidate, receiver side */    
                            /*      
                            console.log("ready to exchange icecandidate")
                            peerConnection.onicecandidate = ({ candidate }) => {   
                                socket.send(JSON.stringify({ type: 'iceCandidate', candidate: candidate, target: jsonObj.sender}));
                                if (candidate) {
                                    console.log(`found new icecandidate, type ${candidate.candidate} , sending`);
                                }else{
                                    console.log("ERROR! No icecandidate!");
                                }
                            };
                            */

                            peerConnection.onicegatheringstatechange = () => {
                                console.log("ICE Gathering State:", peerConnection.iceGatheringState);
                            };
                            
                            peerConnection.onconnectionstatechange = () => {
                                console.log('PeerConnection State:', peerConnection.connectionState);
                            };
                            
                            break;
                            
                        case 'iceCandidate':
                            console.log("peerConnection has received icecandidate");
                            let candidate = new RTCIceCandidate(jsonObj.candidate);
                            try{
                                await peerConnection.addIceCandidate(candidate);
                                console.log('ICE Candidate added successfully');
                            }catch(e){
                                console.error('Error adding ICE Candidate', e);
                            }
                            
                            
                            break;
                        
                        default:
                            console.log("ERROR, unrecognized signal!");
                    }
                };
        
                socket.onclose = () => {
                    updateUserList([]); //clear user list
                    console.log('WebSocket connection closed');
                };
        
                socket.onerror = (error) => {
                    console.log('WebSocket error:', error);
                };
            }else{
                console.log("WARNING, you already have a connection!");
            }
        }
        
        //bind function with ping button
        //ping websocket server, and the peer connection webrtc data channel
        document.getElementById('ping').onclick = () =>{
            //console.log("socket state is " + (socket.readyState === WebSocket.OPEN));
            if (socket.readyState === WebSocket.OPEN) {
                let message = {
                    text: 'A friendly message sent by client side',
                    type: 'message'
                }

                socket.send(JSON.stringify(message));
                console.log('Websocket connection is open, a message sent to server');
            } else {
                console.log('WebSocket connection is not open');
            }

            if(dataChannel.readyState === "open"){
                dataChannel.send(`Message by peer ${username}`);
                console.log("data channel is open and a message is sent");
            }else{
                console.log("data channel is not open!");
            }
        }


        //bind function with sendPeer button
        //send webRTC offer via websocket
        document.getElementById('sendPeer').onclick = () => sendPeer();
        function sendPeer(){
            var targetUsername = document.getElementById('peerUsernameInput').value;
            //socket.send(JSON.stringify({type: 'offer', message: `Peer message from ${username}`, target: targetUsername, sender: username})); DEBUG
            setupWebRTC(targetUsername);
        }


        //webrtc set up, sender side
        async function setupWebRTC(targetUsername){
            if(!userlist.includes(targetUsername)){
                console.log("ERROR, the user you are trying to call does not exist!");
                return;
            }

            // Create the RTCPeerConnection
            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]  // Optional: Add STUN for testing
                //iceServers: []
            });

            // Set up ICE candidate handler (moved to iceready for flowcontrol)(Moved back)
            peerConnection.onicecandidate = ({ candidate }) => {
                console.log("peerConnection has received icecandidate");
                if (candidate) {
                    console.log("new icecandidate found: " + candidate.candidate);
                    socket.send(JSON.stringify({ type: 'iceCandidate', candidate: candidate, target: targetUsername , sender: username}));
                }
            };

            // Create a data channel for file transfer
            dataChannel = peerConnection.createDataChannel('fileTransfer');

            // Handle data channel events
            dataChannel.onopen = () => {
                console.log('Data channel is open');
                //const message = `Hello from ${username}`;
                //dataChannel.send(message);
                //console.log(`Sent message: ${message}`);
            }

            dataChannel.onmessage = (event) => {

            };

            // Create and send SDP offer to target
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            socket.send(JSON.stringify({ type: 'offer', offer: offer, target: targetUsername, sender: username}));


            

            console.log(`send offer to peer ${targetUsername}`);
        }

        //bind function with disconnect button
        document.getElementById('disconnect').onclick = () =>{
            socket.close();
        }
    
    
        function log(text) {
            var time = new Date();
            console.log("[" + time.toLocaleTimeString() + "] " + text);
        }
        
        function updateUserList(userlist){
            const userListDiv = document.getElementById('userList');
    
            // Clear the current list
            userListDiv.innerHTML = '';

            // Populate the new list
            userlist.forEach(user => {
                const listItem = document.createElement('li');
                listItem.textContent = user;
                userListDiv.appendChild(listItem);
            });
        }

        function logUserList(userlist){
            let userlistLog = "userlist: [";
            for(let i=0; i<userlist.length; i++){
                userlistLog += userlist[i];
                if(i != userlist.length-1){
                    userlistLog += ",";
                }
            }
            userlistLog += "]";
            console.log(userlistLog);
        }



        /*
            File Handling 
        */
        let fileToSend = null;
        let receivedChunks = [];
        //let fileMetadata = null;
        let receivedBytes = 0;
        let fileSize = 0;
        let fileType = null;
        let fileName = null;
        let sendingPaused = false;

        // DOM elements for file handling
        const fileInput = document.getElementById('fileInput');
        const sendProgress = document.getElementById('sendProgress');
        const sendStatus = document.getElementById('sendStatus');
        const fileNameElement = document.getElementById('fileName');
        const fileSizeElement = document.getElementById('fileSize');



        // --- File Selection (Sender) ---
        fileInput.addEventListener('change', (event) => {
            fileToSend = event.target.files[0];
            if (fileToSend) {
                fileNameElement.textContent = `File: ${fileToSend.name}`;
                
                let sizeUnitArray = ["byte", "KB", "MB", "GB"];
                let sizeUnit = 0;
                let sizeDisplay = fileToSend.size;
                for(let i=0; i<4; i++){
                    if(sizeDisplay >= 1024){
                        sizeDisplay /= 1024;
                        sizeUnit++;
                    }
                }

                fileSizeElement.textContent = `Size: ${sizeDisplay.toFixed(2)} ${sizeUnitArray[sizeUnit]}`;
            }
        });

        function sendFileMetadata(file){
            const metadata = {
                type: 'metadata', 
                fileName: file.name,
                fileSize: file.size,
                fileType: file.type
            };
            dataChannel.send(JSON.stringify(metadata)); //DEBUG
        }


        document.getElementById('sendFile').onclick = () => sendFile(fileToSend);
        function sendFile(file){
            const chunkSize = 64 * 1024;  // 64 KB per chunk
            const fileReader = new FileReader();
            const sendLimit = 1024 * 1024; // 1 MB

            let offset = 0;

            console.log("DEBUG function triggered");
            sendFileMetadata(fileToSend);

            // Set a threshold (in bytes) for when the `bufferedamountlow` event should be fired
            dataChannel.bufferedAmountLowThreshold = 512*1024;  // 512 KB
            console.log("DEBUG: buffered amount low threshold = " + dataChannel.bufferedAmountLowThreshold);

            // Monitor when the buffered amount is low, and resume sending data
            dataChannel.onbufferedamountlow = () =>{
                if(sendingPaused){
                    //console.log("Buffer cleared, resuming file transfer...");
                    sendingPaused = false;
                    readNextChunk();
                }
            }
            
            fileReader.onload = (event) => {
                const chunk = event.target.result;
                
                if (dataChannel.bufferedAmount < sendLimit) {
                    dataChannel.send(chunk);    //do not send json because chunk is binary and can't be serialized

                    offset += chunkSize;

                    //console.log(chunk);   DEBUG
                    //console.log("chunk size = " +  chunk.byteLength); DEBUG

                    const percentComplete = (offset/file.size)*100;
                    sendProgress.value = percentComplete;
                    sendStatus.textContent = `Status: ${percentComplete.toFixed(2)}% sent`;

                    if(offset < file.size){
                        readNextChunk();
                    }else{
                        sendStatus.textContent = 'Status: Transfer Complete';
                        console.log('File sent successfully');
                    }
                }else{
                    //console.log(`Buffer full: ${dataChannel.bufferedAmount}, pausing...`);
                    sendingPaused = true;
                }
            };

            function readNextChunk() {
                if (!sendingPaused) {
                    const slice = file.slice(offset, offset + chunkSize);
                    fileReader.readAsArrayBuffer(slice);  // Read the chunk as ArrayBuffer
                }
            }

            readNextChunk();  // Start reading the first chunk
        }

        //bind function with disconnect button in file transfer section
        document.getElementById('channelDisconnect').onclick = () =>{
            dataChannel.close();
            console.log("peer data channel disconnected");
        }

        function reconstructAndDownloadFile() {
            const blob = new Blob(receivedChunks, { fileType });
            const downloadURL = URL.createObjectURL(blob);

            const downloadLink = document.getElementById('downloadLink');
            // Show download link
            downloadLink.href = downloadURL;
            downloadLink.download = fileName;
            downloadLink.style.display = 'flex';
            downloadLink.textContent = `Download ${fileName}`;
        }

    </script>
 </body>


 </html>